"use strict";(globalThis.webpackChunkgeowebmap=globalThis.webpackChunkgeowebmap||[]).push([[345],{60345:(e,r,t)=>{t.r(r),t.d(r,{BufferObject:()=>n.f,FramebufferObject:()=>s.X,Program:()=>o.$,ProgramCache:()=>a.G,Renderbuffer:()=>i.r,ShaderCompiler:()=>l.B,Texture:()=>c.x,VertexArrayObject:()=>f.U,createContextOrErrorHTML:()=>u.sj,createProgram:()=>d.H,glslifyDefineMap:()=>h.K});var n=t(44070),s=t(53634),o=t(52714),a=t(68267),i=t(15880),l=t(56648),c=t(371),f=t(45412),h=t(65706),d=t(96721),u=t(49800)},96721:(e,r,t)=>{t.d(r,{H:()=>s});var n=t(52714);function s(e,r){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return new n.$(e,t+r.shaders.vertexShader,t+r.shaders.fragmentShader,r.attributes)}},56648:(e,r,t)=>{t.d(r,{B:()=>n});class n{constructor(e){this.readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Map;if(r.has(e))return r.get(e);const t=this._read(e);if(!t)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let s=n.exec(t);const o=[];for(;null!=s;)o.push({path:s[1],start:s.index,length:s[0].length}),s=n.exec(t);let a=0,i="";return o.forEach((e=>{i+=t.slice(a,e.start),i+=r.has(e.path)?"":this._resolve(e.path,r),a=e.start+e.length})),i+=t.slice(a),r.set(e,i),i}_read(e){return this.readFile(e)}}},65706:(e,r,t)=>{function n(e){let r="";for(const t in e){const n=e[t];if("boolean"==typeof n)n&&(r+=`#define ${t}\n`);else if("number"==typeof n)r+=`#define ${t} ${n.toFixed()}\n`;else if("object"==typeof n){const e=n.options;let s=0;for(const t in e)r+=`#define ${e[t]} ${(s++).toFixed()}\n`;r+=`#define ${t} ${e[n.value]}\n`}}return r}t.d(r,{K:()=>n})}}]);
//# sourceMappingURL=345.0e6f479c.chunk.js.map